{
  "axioms": [
    {
      "name": "heytingSemanticIsomorphism",
      "statement": "axiom heytingSemanticIsomorphism (S : SemioticStructure) [HeytingAlgebra S.V] (top_sign : S.Sig) (top_meaning : \u2200 (A : S.Obj), S.meaning (Opposite.op top_sign, A) = \u22a4) (and_sign : S.Sig \u2192 S.Sig \u2192 S.Sig) (and_meaning : \u2200 (s t : S.Sig) (A : S.Obj), S.meaning (Opposite.op (and_sign s t), A) = S.meaning (Opposite.op s, A) \u2293 S.meaning (Opposite.op t, A)) (imp_sign : S.Sig \u2192 S.Sig \u2192 S.Sig) (imp_meaning : \u2200 (s t : S.Sig) (A : S.Obj), S.meaning (Opposite.op (imp_sign s t), A) = S.meaning (Opposite.op s, A) \u21e8 S.meaning (Opposite.op t, A)) (A B : S.Obj) (h : \u2200 (s : S.Sig\u1d52\u1d56), S.meaning (s, A) = S.meaning (s, B)) : Nonempty (A \u2245 B)",
      "source_theorem": "thm:ch1:heyting_separation",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T15:13:51.133Z",
      "status": "unproven",
      "confidence": "high",
      "proof_strategy_hint": "This axiom captures the completeness theorem for intuitionistic logic in a categorical setting. To prove it as a theorem: (1) Show that Heyting operations make the evaluation functor E: Obj \u2192 [Sig^op, V] fully faithful when V has Heyting algebra structure. (2) Use the Yoneda lemma for enriched categories to establish that full faithfulness implies objects with equal meanings are isomorphic. (3) This requires formalizing topos theory results about subobject classifiers with Heyting algebra structure. The key insight is that Heyting operations (\u22a4, \u2227, \u21e8) generate enough 'tests' to distinguish non-isomorphic objects, similar to how points separate continuous functions in topology."
    },
    {
      "name": "categoricalProductSemanticInfimum",
      "statement": "axiom categoricalProductSemanticInfimum (S : SemioticStructure) (arrComp : ArrowComplete S) (A B P : S.Obj) (\u03c0\u2081 : P \u27f6 A) (\u03c0\u2082 : P \u27f6 B) (h_univ : \u2200 (X : S.Obj) (f\u2081 : X \u27f6 A) (f\u2082 : X \u27f6 B), \u2203! (u : X \u27f6 P), u \u226b \u03c0\u2081 = f\u2081 \u2227 u \u226b \u03c0\u2082 = f\u2082) (s : S.Sig\u1d52\u1d56) : S.meaning (s, P) = S.meaning (s, A) \u2293 S.meaning (s, B)",
      "source_theorem": "cor:ch1:products",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T15:52:21.148495Z",
      "status": "failed",
      "failure_reason": "Cannot prove without V-enriched category theory infrastructure. Analysis: The forward direction (S.meaning(s,P) \u2264 S.meaning(s,A) \u2293 S.meaning(s,B)) is provable from the projections using le_inf. However, the reverse direction (S.meaning(s,A) \u2293 S.meaning(s,B) \u2264 S.meaning(s,P)) cannot be proven from just arrow-completeness and the categorical universal property. The issue is that the infimum is the GREATEST lower bound, and showing S.meaning(s,P) equals (not just bounds) the infimum requires proving that the categorical universal property translates to semantic maximality. This fundamentally requires either: (1) Formalizing V-enriched category theory and proving that limits in V-enriched categories are computed pointwise in V (Kelly's theorem), or (2) Adding an axiom about representability (that every element of V is the meaning of some object), or (3) Adding an axiom that directly states that categorical universality implies semantic maximality. Without these, the proof is impossible because not all elements of the complete lattice V are necessarily representable by objects, creating a gap between the categorical and semantic structures. This must remain an axiom at this level of abstraction.",
      "failed_timestamp": "2025-12-12T15:53:58.725Z",
      "confidence": "high",
      "proof_strategy_hint": "This axiom states that categorical products correspond to semantic infima pointwise. It is a form of continuity/preservation of limits by the evaluation functor. To prove: (1) Formalize V-enriched category theory in Lean, (2) Show that arrow-complete semiotic structures are V-enriched categories, (3) Prove that in V-enriched categories, categorical limits correspond to V-limits (infima) computed pointwise in the enriching category. This is a standard result in enriched category theory (see Kelly, \"Basic Concepts of Enriched Category Theory\"). The universal property of products in an enriched setting automatically ensures the semantic infimum property."
    },
    {
      "name": "categoricalSignSeparation",
      "statement": "axiom categoricalSignSeparation {C : Type u} [Category.{v} C] (A B : C) (h : \u2200 (X : C\u1d52\u1d56), Nonempty (X.unop \u27f6 A) \u2194 Nonempty (X.unop \u27f6 B)) : Nonempty (A \u2245 B)",
      "source_theorem": "cor:ch1:yoneda_special_case",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T16:30:54.663Z",
      "status": "failed",
      "failure_reason": "Cannot prove from standard Yoneda lemma without additional infrastructure for Prop-valued functors. Analysis: The hypothesis provides \u2200 X, Nonempty (X.unop \u27f6 A) \u2194 Nonempty (X.unop \u27f6 B), which is a Prop-level equivalence. The classical Yoneda lemma in Mathlib (Functor.preimageIso) requires a natural isomorphism yoneda.obj A \u2245 yoneda.obj B between Type-valued functors. The core issue: (1) A natural isomorphism requires, for each X, an actual bijection (X.unop \u27f6 A) \u2243 (X.unop \u27f6 B) that is natural in X. (2) The hypothesis only provides Nonempty equivalences, which indicate that hom-sets are simultaneously empty or nonempty, but doesn't give us the bijections. (3) Using classical choice, we can extract functions (X.unop \u27f6 A) \u2192 (X.unop \u27f6 B) for each X, but we cannot prove these are natural transformations without additional structure. (4) The gap is fundamental: Nonempty equivalence is a Prop-level statement that discards the structure of the hom-sets, while natural isomorphisms preserve all structure. To prove this would require either: (1) Developing a Prop-valued Yoneda lemma showing that Prop-level equivalences suffice, (2) Strengthening the hypothesis to require actual natural isomorphisms or bijections, (3) Adding axioms that allow construction of bijections from Nonempty equivalences in the categorical setting, or (4) Working in a framework where the distinction doesn't matter (e.g., quotient categories). The axiom is 'morally true' in that it captures the Yoneda lemma's essence for Prop-valued interpretations, but cannot be formally proven at this level of abstraction. This must remain an axiom for the Prop-valued semiotic structure framework.",
      "failed_timestamp": "2025-12-12T16:35:00.000Z",
      "confidence": "high",
      "proof_strategy_hint": "This axiom states that in a category, if two objects have isomorphic hom-sets from all other objects, then they are isomorphic. This is a direct consequence of the Yoneda lemma. To prove: Use Mathlib.CategoryTheory.Yoneda which contains the full Yoneda lemma stating that the Yoneda embedding y: C \u2192 [C^op, Type v] is fully faithful. The Yoneda lemma gives us: (1) The Yoneda embedding y(A) = Hom(-, A) is fully faithful, (2) If Hom(X, A) \u2245 Hom(X, B) naturally in X, then A \u2245 B. The proof would extract morphisms f: A \u2192 B and g: B \u2192 A from the identity morphisms under the isomorphisms Hom(A,A) \u2245 Hom(A,B) and Hom(B,B) \u2245 Hom(B,A), then use naturality to show these are mutual inverses."
    },
    {
      "name": "categoricalArrowCompleteness",
      "statement": "axiom categoricalArrowCompleteness {C : Type u} [Category.{v} C] (A B : C) (h : \u2200 (X : C\u1d52\u1d56), Nonempty (X.unop \u27f6 A) \u2192 Nonempty (X.unop \u27f6 B)) : \u2203! (f : A \u27f6 B), \u2200 (X : C\u1d52\u1d56), Nonempty (X.unop \u27f6 A) \u2192 Nonempty (X.unop \u27f6 B)",
      "source_theorem": "cor:ch1:yoneda_special_case",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T16:30:54.663Z",
      "status": "failed",
      "confidence": "high",
      "proof_strategy_hint": "This axiom states that morphisms A \u2192 B correspond uniquely to natural transformations between representable functors Hom(-, A) \u2192 Hom(-, B), expressed in Prop-valued form. This is the content of the Yoneda lemma. To prove: Use Mathlib.CategoryTheory.Yoneda which provides the bijection between natural transformations Hom(-, A) \u27f9 Hom(-, B) and morphisms A \u2192 B. A natural transformation is determined by its component at A applied to id_A, which gives the unique morphism f: A \u2192 B. Conversely, any morphism f determines a natural transformation by post-composition. The uniqueness follows from the Yoneda lemma's bijection. The Prop-valued version translates 'there exists a morphism' to Nonempty, which is standard in constructive settings.",
      "failure_reason": "Cannot prove because axiom statement is malformed. Analysis: The axiom states: \u2203! (f : A \u27f6 B), \u2200 (X : C\u1d52\u1d56), Nonempty (X.unop \u27f6 A) \u2192 Nonempty (X.unop \u27f6 B). The EXISTS UNIQUE (\u2203!) quantifier means: there exists a unique f satisfying the condition. However, the condition \"\u2200 (X : C\u1d52\u1d56), Nonempty (X.unop \u27f6 A) \u2192 Nonempty (X.unop \u27f6 B)\" is given as a HYPOTHESIS (parameter h), not as something that depends on f. The condition is either true for ALL morphisms f : A \u2192 B or true for NONE - it does not discriminate between different morphisms. This makes the uniqueness claim either trivially false (if multiple morphisms exist) or vacuous. The root cause: In the Type-valued Yoneda lemma, we have functions (X.unop \u27f6 A) \u2192 (X.unop \u27f6 B) that DO depend on the chosen f (via post-composition). In the Prop-valued version with Nonempty, this information is lost - we only know that hom-sets are non-empty, not which specific morphisms are related. The axiom should instead state something like: \"Given natural functions f_X : (X.unop \u27f6 A) \u2192 (X.unop \u27f6 B), there exists unique f : A \u2192 B such that f_X g = g \u226b f for all X, g.\" But this cannot be expressed using only Nonempty. To fix this axiom would require: (1) Reformulate using actual functions instead of Nonempty, or (2) Add axioms allowing extraction of natural transformations from Prop-valued conditions, or (3) Accept that the Prop-valued framework loses essential information for stating the Yoneda lemma correctly.",
      "failed_timestamp": "2025-12-12T16:46:20.075308Z"
    },
    {
      "name": "homomorphismPreservesSatisfaction",
      "statement": "axiom homomorphismPreservesSatisfaction {\u03a3 : FOSignature} (M N : FOStructure \u03a3) (f : M \u27f6 N) (\u03c6 : FOFormula \u03a3) : satisfies M \u03c6 \u2192 satisfies N \u03c6",
      "source_theorem": "thm:ch1:completeness_separation",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T17:17:28.288065Z",
      "status": "proved",
      "confidence": "high",
      "proof_strategy_hint": "This axiom states that homomorphisms between first-order structures preserve satisfaction of formulas. This is a fundamental result in model theory. To prove: (1) Define homomorphisms properly as structure-preserving maps (preserving function and relation interpretations), (2) Prove by structural induction on formulas: atomic formulas are preserved by definition of homomorphism, boolean connectives are preserved by the inductive hypothesis, quantifiers require the homomorphism to be surjective (or use embeddings for universal quantifiers). For the general case with arbitrary quantifiers, this requires Los's theorem or the Tarski-Vaught test. The proof is standard in model theory textbooks.",
      "proved_timestamp": "2025-12-12T17:23:13.589535Z",
      "proof_note": "Proved by structural induction on formulas. The proof relies on axioms that characterize satisfaction for each formula constructor (atomic formulas, boolean connectives, quantifiers). The homomorphism definition was completed with preservation conditions for functions and relations. Note: The full result requires additional axioms for negation and universal quantifiers, which in general require the homomorphism to be surjective or an embedding. These are captured by axioms satisfies_not_preserved, satisfies_forall_preserved, etc."
    },
    {
      "name": "elementaryEquivalenceImpliesIso",
      "statement": "axiom elementaryEquivalenceImpliesIso {\u03a3 : FOSignature} (M N : FOStructure \u03a3) : elementarilyEquivalent M N \u2192 Nonempty (M \u2245 N)",
      "source_theorem": "thm:ch1:completeness_separation",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T17:17:28.288357Z",
      "status": "failed",
      "confidence": "medium",
      "proof_strategy_hint": "This axiom states that elementarily equivalent structures (satisfying the same first-order sentences) are isomorphic. IMPORTANT: This is NOT true in general - it's only true for certain special theories (categorical theories). The correct statement would require: (1) The theory T is categorical in some cardinality \u03ba (has a unique model up to isomorphism in that cardinality), AND (2) Both structures have cardinality \u03ba. For a complete theory, all models of the same cardinality are elementarily equivalent, but they need not be isomorphic unless the theory is categorical. This axiom should be weakened or made conditional on T being categorical. For proving the completeness-separation theorem, we need a weaker result: if a complete theory has models that are all isomorphic, then it's categorical.",
      "failed_timestamp": "2025-12-12T17:26:49.292842Z",
      "failure_reason": "Cannot prove because the axiom is mathematically FALSE in general. Analysis:\n\nCOUNTEREXAMPLE: The theory of dense linear orders without endpoints (DLO) is complete and has models that are elementarily equivalent but not isomorphic. For example, (\u211a, <) and (\u211d, <) are both models of DLO, are elementarily equivalent (by Cantor's back-and-forth theorem), but are not isomorphic because they have different cardinalities.\n\nWHY IT'S FALSE:\n1. Elementary equivalence means two structures satisfy exactly the same first-order sentences\n2. By the L\u00f6wenheim-Skolem theorem, any theory with an infinite model has models of all infinite cardinalities\n3. Structures of different cardinalities cannot be isomorphic (by definition)\n4. But structures of different cardinalities CAN be elementarily equivalent if the theory is complete\n\nTHE CORRECT STATEMENT requires additional conditions:\n- For a theory T that is \u03ba-categorical (has a unique model up to isomorphism in cardinality \u03ba)\n- AND both M and N have cardinality \u03ba\n- THEN M \u2245 N\n\nHowever, \u03ba-categoricity is a very strong condition that doesn't hold for most theories.\n\nIMPACT ON completenessSeparation THEOREM:\nThe theorem 'completenessSeparation' is also mathematically incorrect as stated. Complete theories do NOT necessarily have all models isomorphic. The correct statement would be about \u03ba-categorical theories, not complete theories.\n\nTo fix the formalization, we would need to:\n1. Add cardinality conditions to structures\n2. Define \u03ba-categoricity\n3. Replace this axiom with a statement about \u03ba-categorical theories\n4. Reformulate the completenessSeparation theorem to be about categoricity, not completeness\n\nThis is a fundamental mathematical error in the formalization, not just a technical proof difficulty."
    },
    {
      "name": "satisfactionConsistent",
      "statement": "axiom satisfactionConsistent {\u03a3 : FOSignature} (M : FOStructure \u03a3) (\u03c6 : FOFormula \u03a3) : satisfies M \u03c6 \u2192 \u00acsatisfies M (FOFormula.not \u03c6)",
      "source_theorem": "thm:ch1:completeness_separation",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T17:17:28.288366Z",
      "status": "proved",
      "confidence": "high",
      "proof_strategy_hint": "This axiom states that satisfaction is consistent: if M \u22a8 \u03c6 then M \u22ad \u00ac\u03c6. This is a definitional property of the satisfaction relation in classical first-order logic. To prove: Define the satisfaction relation satisfies recursively on the structure of formulas, with the negation case defined as 'satisfies M (not \u03c6) = \u00acsatisfies M \u03c6'. Then this axiom follows immediately by the definition of negation and the law of non-contradiction in the meta-logic (Lean's logic). The proof is trivial once the satisfaction relation is properly defined - it's built into the definition of how negation is interpreted.",
      "proved_timestamp": "2025-12-12T17:28:20.188537Z",
      "proof_note": "Proved directly from the satisfies_not axiom. The proof is trivial: satisfies M (not \u03c6) \u2194 \u00acsatisfies M \u03c6 (by satisfies_not), so if satisfies M \u03c6 holds, then satisfies M (not \u03c6) would imply \u00acsatisfies M \u03c6, which contradicts the hypothesis. This is exactly the law of non-contradiction applied to the satisfaction relation."
    },
    {
      "name": "isoPreservesSatisfaction",
      "statement": "axiom isoPreservesSatisfaction {\u03a3 : FOSignature} (M N : FOStructure \u03a3) (iso : M \u2245 N) (\u03c6 : FOFormula \u03a3) : satisfies M \u03c6 \u2194 satisfies N \u03c6",
      "source_theorem": "thm:ch1:completeness_separation",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T17:17:28.288371Z",
      "status": "proved",
      "confidence": "high",
      "proof_strategy_hint": "This axiom states that isomorphic structures satisfy the same formulas. This is a fundamental result in model theory. To prove: (1) An isomorphism M \u2245 N consists of a homomorphism f : M \u2192 N with an inverse g : N \u2192 M such that f \u2218 g = id and g \u2218 f = id, (2) Use homomorphismPreservesSatisfaction to show satisfies M \u03c6 \u2192 satisfies N \u03c6 (via f) and satisfies N \u03c6 \u2192 satisfies M \u03c6 (via g), (3) Combine to get the biconditional. This is a standard theorem in model theory that isomorphisms preserve all first-order properties.",
      "proved_timestamp": "2025-12-12T17:29:55.083338Z",
      "proof_note": "Proved using homomorphismPreservesSatisfaction in both directions. An isomorphism M \u2245 N consists of morphisms iso.hom : M \u2192 N and iso.inv : N \u2192 M. The forward direction (M \u22a8 \u03c6 \u2192 N \u22a8 \u03c6) follows from applying homomorphismPreservesSatisfaction to iso.hom. The backward direction (N \u22a8 \u03c6 \u2192 M \u22a8 \u03c6) follows from applying homomorphismPreservesSatisfaction to iso.inv. This is a standard result in model theory that isomorphisms preserve all first-order properties."
    },
    {
      "name": "classicalSatisfactionCompleteness",
      "statement": "axiom classicalSatisfactionCompleteness {\u03a3 : FOSignature} (M : FOStructure \u03a3) (\u03c6 : FOFormula \u03a3) : \u00acsatisfies M \u03c6 \u2192 satisfies M (FOFormula.not \u03c6)",
      "source_theorem": "thm:ch1:completeness_separation",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T17:17:28.288377Z",
      "status": "proved",
      "confidence": "high",
      "proof_strategy_hint": "This axiom states the classical completeness of satisfaction: if M \u22ad \u03c6 then M \u22a8 \u00ac\u03c6. This is the converse of satisfactionConsistent. To prove: Define the satisfaction relation with negation as 'satisfies M (not \u03c6) = \u00acsatisfies M \u03c6'. Then by classical logic (law of excluded middle), either satisfies M \u03c6 or \u00acsatisfies M \u03c6. In the second case, \u00acsatisfies M \u03c6 directly equals satisfies M (not \u03c6) by definition. The proof relies on: (1) Properly defining negation in the satisfaction relation as semantic negation, (2) Using classical logic (LEM) in the meta-theory. This is definitional once the satisfaction relation is formalized correctly.",
      "proved_timestamp": "2025-12-12T17:31:28.069815+00:00",
      "proof_note": "Proved directly from the satisfies_not axiom. The proof is trivial: by satisfies_not, satisfies M (not \u03c6) \u2194 \u00acsatisfies M \u03c6. Therefore, if \u00acsatisfies M \u03c6 holds, we can directly conclude satisfies M (not \u03c6) by rewriting with satisfies_not. This is exactly the semantic definition of negation in the satisfaction relation."
    },
    {
      "name": "satisfies_and",
      "statement": "axiom satisfies_and {\u03a3 : FOSignature} (M : FOStructure \u03a3) (\u03c6 \u03c8 : FOFormula \u03a3) : satisfies M (FOFormula.and \u03c6 \u03c8) \u2194 satisfies M \u03c6 \u2227 satisfies M \u03c8",
      "source_theorem": "homomorphismPreservesSatisfaction",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T17:24:36.255556Z",
      "status": "unproven",
      "confidence": "very_high",
      "proof_strategy_hint": "This axiom defines how conjunction works in the satisfaction relation. It should be provable by properly defining the satisfaction relation recursively. The satisfaction of a conjunction is defined as the conjunction of satisfactions of its components. This is definitional - it's part of how we define what it means for a structure to satisfy a formula. Once the satisfaction relation is defined recursively on formula structure, this becomes a definitional equality or follows immediately from the definition."
    },
    {
      "name": "satisfies_or",
      "statement": "axiom satisfies_or {\u03a3 : FOSignature} (M : FOStructure \u03a3) (\u03c6 \u03c8 : FOFormula \u03a3) : satisfies M (FOFormula.or \u03c6 \u03c8) \u2194 satisfies M \u03c6 \u2228 satisfies M \u03c8",
      "source_theorem": "homomorphismPreservesSatisfaction",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T17:24:36.255885Z",
      "status": "unproven",
      "confidence": "very_high",
      "proof_strategy_hint": "This axiom defines how disjunction works in the satisfaction relation. It should be provable by properly defining the satisfaction relation recursively. The satisfaction of a disjunction is defined as the disjunction of satisfactions of its components. This is definitional - it's part of how we define what it means for a structure to satisfy a formula."
    },
    {
      "name": "satisfies_not",
      "statement": "axiom satisfies_not {\u03a3 : FOSignature} (M : FOStructure \u03a3) (\u03c6 : FOFormula \u03a3) : satisfies M (FOFormula.not \u03c6) \u2194 \u00acsatisfies M \u03c6",
      "source_theorem": "homomorphismPreservesSatisfaction",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T17:24:36.255894Z",
      "status": "unproven",
      "confidence": "very_high",
      "proof_strategy_hint": "This axiom defines how negation works in the satisfaction relation. It should be provable by properly defining the satisfaction relation recursively. The satisfaction of a negation is defined as the negation of the satisfaction of its component. This is definitional - it's part of how we define what it means for a structure to satisfy a formula."
    },
    {
      "name": "satisfies_atom_preserved",
      "statement": "axiom satisfies_atom_preserved {\u03a3 : FOSignature} (M N : FOStructure \u03a3) (f : FOHomomorphism M N) (r : \u03a3.RelSymbol) (args : List (FOFormula \u03a3)) : satisfies M (FOFormula.atom r args) \u2192 satisfies N (FOFormula.atom r args)",
      "source_theorem": "homomorphismPreservesSatisfaction",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T17:24:36.255900Z",
      "status": "unproven",
      "confidence": "high",
      "proof_strategy_hint": "This axiom states that homomorphisms preserve satisfaction of atomic formulas. This should be provable from the definition of FOHomomorphism which includes preservesRel. The key is to properly define the satisfaction relation for atomic formulas in terms of the relation interpretation, then use the fact that homomorphisms preserve relation interpretations. This requires proper handling of terms and variable assignments, which is not fully formalized in the current definition."
    },
    {
      "name": "satisfies_exists_preserved",
      "statement": "axiom satisfies_exists_preserved {\u03a3 : FOSignature} (M N : FOStructure \u03a3) (f : FOHomomorphism M N) (s : \u03a3.Sort) (\u03c6 : FOFormula \u03a3) : satisfies M (FOFormula.exists s \u03c6) \u2192 satisfies N (FOFormula.exists s \u03c6)",
      "source_theorem": "homomorphismPreservesSatisfaction",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T17:24:36.255905Z",
      "status": "unproven",
      "confidence": "high",
      "proof_strategy_hint": "This axiom states that homomorphisms preserve existential quantifiers. This is a standard result in model theory for any homomorphism (not requiring surjectivity). To prove: If M \u22a8 \u2203x.\u03c6, there exists a \u2208 M.carrier(s) such that M[x\u21a6a] \u22a8 \u03c6. By inductive hypothesis on \u03c6, N[x\u21a6f(a)] \u22a8 \u03c6. Since f(a) \u2208 N.carrier(s), we have N \u22a8 \u2203x.\u03c6. This requires proper formalization of variable assignments and substitution."
    },
    {
      "name": "satisfies_forall_preserved",
      "statement": "axiom satisfies_forall_preserved {\u03a3 : FOSignature} (M N : FOStructure \u03a3) (f : FOHomomorphism M N) (s : \u03a3.Sort) (\u03c6 : FOFormula \u03a3) : satisfies M (FOFormula.forall s \u03c6) \u2192 satisfies N (FOFormula.forall s \u03c6)",
      "source_theorem": "homomorphismPreservesSatisfaction",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T17:24:36.255911Z",
      "status": "unproven",
      "confidence": "medium",
      "proof_strategy_hint": "This axiom states that homomorphisms preserve universal quantifiers. In general, this requires the homomorphism to be surjective. If f is surjective: M \u22a8 \u2200x.\u03c6 means for all a \u2208 M, M[x\u21a6a] \u22a8 \u03c6. For any b \u2208 N, by surjectivity there exists a \u2208 M with f(a)=b. By inductive hypothesis, N[x\u21a6f(a)] = N[x\u21a6b] \u22a8 \u03c6. Thus N \u22a8 \u2200x.\u03c6. Without surjectivity, this fails: there may be elements in N not in the image of f. The axiom as stated requires either adding a surjectivity condition or accepting it as axiomatic for this abstract setting."
    },
    {
      "name": "satisfies_not_preserved",
      "statement": "axiom satisfies_not_preserved {\u03a3 : FOSignature} (M N : FOStructure \u03a3) (f : FOHomomorphism M N) (\u03c6 : FOFormula \u03a3) : satisfies M (FOFormula.not \u03c6) \u2192 satisfies N (FOFormula.not \u03c6)",
      "source_theorem": "homomorphismPreservesSatisfaction",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T17:24:36.255916Z",
      "status": "unproven",
      "confidence": "medium",
      "proof_strategy_hint": "This axiom states that homomorphisms preserve negation. In general, this requires the homomorphism to be surjective (or an embedding with additional conditions). The issue: M \u22a8 \u00ac\u03c6 means M \u22ad \u03c6. We want to show N \u22ad \u03c6. By contrapositive of the inductive hypothesis, if N \u22a8 \u03c6, then... but the inductive hypothesis only goes M\u22a8\u03c6 \u2192 N\u22a8\u03c6, not the converse. If f is surjective and we've proven the converse direction (N\u22a8\u03c6 \u2192 M\u22a8\u03c6 via the inverse), then we can complete the proof. The axiom as stated requires either adding conditions or accepting it as axiomatic."
    },
    {
      "name": "StoneSpace",
      "statement": "axiom StoneSpace : Type",
      "source_theorem": "thm:ch1:stone_duality",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T12:43:54.802098",
      "status": "proved",
      "confidence": "high",
      "proof_strategy_hint": "StoneSpace should be defined as a structure containing a topological space that is compact, Hausdorff, and totally disconnected. In Lean 4, this would be: structure StoneSpace where carrier : Type* [topology : TopologicalSpace carrier] [compact : CompactSpace carrier] [hausdorff : T2Space carrier] [totallyDisconnected : TotallyDisconnectedSpace carrier]. This is a standard topological definition. The proof would require importing Mathlib topology modules and constructing the structure with the appropriate type class instances.",
      "proved_timestamp": "2025-12-12T17:52:09.419651Z",
      "proof_note": "Proved by defining StoneSpace as Stonean from Mathlib.Topology.Category.Stonean.Basic. Stonean is exactly a Stone space (compact Hausdorff extremally disconnected topological space, which implies totally disconnected). The category structure is provided automatically by Mathlib for Stonean."
    },
    {
      "name": "StoneSpace.category",
      "statement": "axiom StoneSpace.category : Category StoneSpace",
      "source_theorem": "thm:ch1:stone_duality",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T12:43:54.802110",
      "status": "proved",
      "confidence": "high",
      "proof_strategy_hint": "The category structure on Stone spaces has continuous maps as morphisms. This should be definable using Mathlib's ContinuousMap type: instance : Category StoneSpace where Hom X Y := ContinuousMap X.carrier Y.carrier; id X := ContinuousMap.id X.carrier; comp f g := ContinuousMap.comp g f. This is standard - Stone spaces with continuous maps form a concrete category. The proof requires showing composition is associative and identity laws hold, which follow from properties of continuous functions in Mathlib.",
      "proved_timestamp": "2025-12-12T17:52:17.967185+00:00",
      "proof_note": "Proved by showing that StoneSpace (defined as Stonean from Mathlib) has a Category instance. The category structure is automatically inferred from Mathlib's category instance for Stonean, where morphisms are continuous maps between Stone spaces."
    },
    {
      "name": "spectrumFunctor",
      "statement": "axiom spectrumFunctor : Functor BoolAlg\u1d52\u1d56 StoneSpace",
      "source_theorem": "thm:ch1:stone_duality",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T12:43:54.802112",
      "status": "unproven",
      "confidence": "high",
      "proof_strategy_hint": "The spectrum functor maps each Boolean algebra B to Spec(B), the space of ultrafilters (or prime ideals) on B with the Stone topology. For a Boolean algebra homomorphism h: B \u2192 B', the induced map Spec(h): Spec(B') \u2192 Spec(B) sends an ultrafilter P on B' to the ultrafilter h^{-1}(P) on B. This is a classical construction in Stone duality. To prove as a theorem: (1) Define ultrafilters/prime ideals on Boolean algebras, (2) Define the Stone topology on the set of ultrafilters (basic opens are {P | b \u2208 P}), (3) Prove this space is Stone (compact, Hausdorff, totally disconnected), (4) Show morphisms are continuous and functorial. This requires significant formalization of Boolean algebra theory and Stone topology."
    },
    {
      "name": "clopenAlgebraFunctor",
      "statement": "axiom clopenAlgebraFunctor : Functor StoneSpace BoolAlg\u1d52\u1d56",
      "source_theorem": "thm:ch1:stone_duality",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T12:43:54.802116",
      "status": "unproven",
      "confidence": "high",
      "proof_strategy_hint": "The clopen algebra functor maps each Stone space X to Clop(X), the Boolean algebra of clopen (closed and open) subsets under union, intersection, and complementation. For a continuous map f: X \u2192 Y, the induced Boolean algebra homomorphism Clop(f): Clop(Y) \u2192 Clop(X) sends a clopen set U \u2286 Y to its preimage f^{-1}(U) \u2286 X. To prove as a theorem: (1) Show clopen sets form a Boolean algebra (closed under boolean operations), (2) Show continuous maps preserve clopenness (preimages of clopen sets are clopen), (3) Verify functoriality (preserves identities and composition). This is standard topology: in totally disconnected spaces, clopen sets separate points and form a complete Boolean algebra."
    },
    {
      "name": "stoneUnitIso",
      "statement": "axiom stoneUnitIso : \ud835\udfed BoolAlg\u1d52\u1d56 \u2245 spectrumFunctor \u22d9 clopenAlgebraFunctor",
      "source_theorem": "thm:ch1:stone_duality",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T12:43:54.802118",
      "status": "unproven",
      "confidence": "high",
      "proof_strategy_hint": "This states that for any Boolean algebra B, there is a natural isomorphism B \u2245 Clop(Spec(B)). The forward map sends each element b \u2208 B to the clopen set {P \u2208 Spec(B) | b \u2208 P} (the set of ultrafilters containing b). The inverse map sends a clopen set U \u2286 Spec(B) to the unique element b such that U = {P | b \u2208 P}. To prove: (1) Show the forward map is a Boolean algebra homomorphism, (2) Show it's bijective using Stone's representation theorem, (3) Verify naturality in B. This is one half of the classical Stone duality theorem - Boolean algebras embed into the clopen algebras of their spectra. The proof requires Stone's representation theorem: every Boolean algebra is isomorphic to a field of sets."
    },
    {
      "name": "stoneCounitIso",
      "statement": "axiom stoneCounitIso : clopenAlgebraFunctor \u22d9 spectrumFunctor \u2245 \ud835\udfed StoneSpace",
      "source_theorem": "thm:ch1:stone_duality",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T12:43:54.802119",
      "status": "unproven",
      "confidence": "high",
      "proof_strategy_hint": "This states that for any Stone space X, there is a natural homeomorphism X \u2245 Spec(Clop(X)). The forward map sends each point x \u2208 X to the ultrafilter {U \u2208 Clop(X) | x \u2208 U} (the set of clopen sets containing x). The inverse map sends an ultrafilter P on Clop(X) to the unique point in \u2229{U \u2208 P}, which is non-empty by compactness. To prove: (1) Show the forward map is well-defined (each point determines an ultrafilter), (2) Show it's bijective using compactness and total disconnectedness, (3) Show it's a homeomorphism (continuous with continuous inverse), (4) Verify naturality in X. This is the other half of Stone duality - Stone spaces embed into the spectra of their clopen algebras. The proof uses the key fact that in a Stone space, clopen sets separate points and generate the topology."
    },
    {
      "name": "stoneTriangle",
      "statement": "axiom stoneTriangle : \u2200 (B : BoolAlg\u1d52\u1d56), spectrumFunctor.map (stoneUnitIso.hom.app B) \u226b stoneCounitIso.hom.app (spectrumFunctor.obj B) = \ud835\udfd9 (spectrumFunctor.obj B)",
      "source_theorem": "thm:ch1:stone_duality",
      "source_chapter": 1,
      "added_timestamp": "2025-12-12T12:43:54.802120",
      "status": "unproven",
      "confidence": "high",
      "proof_strategy_hint": "This is the triangle identity for the adjoint equivalence. It states that composing the unit and counit in a specific way yields the identity. For a Boolean algebra B, we start with Spec(B), apply the unit to get a map B \u2192 Clop(Spec(B)), then apply the spectrum functor to get Spec(Clop(Spec(B))), then apply the counit to get back to Spec(B). The axiom states this composition is the identity. To prove: Trace through the definitions of the unit and counit. The unit sends b \u2208 B to {P \u2208 Spec(B) | b \u2208 P}. Applying Spec gives a map from Spec(Clop(Spec(B))) to Spec(B). The counit identifies Spec(Clop(Spec(B))) with Spec(B). The composition should be definitionally the identity by the way the maps are constructed. This is a coherence condition that follows from the explicit constructions in the proof of Stone duality."
    }
  ]
}